<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Articles on Baniy Cai</title>
    <link>https://baniycai.github.io/article/</link>
    <description>Recent content in Articles on Baniy Cai</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 07 Dec 2023 16:54:34 +0800</lastBuildDate><atom:link href="https://baniycai.github.io/article/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据库崩溃时会发生什么？</title>
      <link>https://baniycai.github.io/article/database_crash/</link>
      <pubDate>Thu, 07 Dec 2023 16:54:34 +0800</pubDate>
      
      <guid>https://baniycai.github.io/article/database_crash/</guid>
      <description>数据库将表和索引存储在文件中。当我们创建行时，数据库系统会写入内存中的数据页(data pages)，然后将其写入磁盘上的数据文件。
这里就产生一个问题辽，如果数据库写入文件中途断电了怎么办？我们需要其它东西来避免崩溃和断电，那就是 WAL(Write-ahead log，预写日志)或重做日志(Redo log)。
当我们写入表和索引时，我们会在这些更改的 WAL 中创建一个日志条目。我们将 WAL 写入它自己的文件，同时也写入内存中的数据页。不写入磁盘上的实际表和索引数据文件是可以的，这些可以保留在内存中，只要我们有日志，我们就可以随时构建表。
WAL 比实际数据文件小得多，因此我们可以相对更快地刷新它们。与随机的数据页更改不同，它们是连续的。引用 Yugabyte 的 Hari 的话
WAL 不仅更小，而且需要更少的 IO。即使其中只有一个bit发生变化，您也必须将整个扇区写入磁盘。 WAL 是仅追加(append only)，您只能写入到文件末尾。如果修改 4 行，数据可能位于 4 个扇区中，但可能只需要 1 个 WAL 扇区。
即使您写入多个 WAL 扇区，它们也是连续的，这比随机 IO 更快。主轴驱动器的优势是巨大的，但即使在 SSD 上，它的速度也更快。
WAL 还可以用于各种用途，例如复制和备份以及崩溃恢复。
如果我们在写入 WAL 时崩溃了怎么办？没错，这就是我们有事务状态的原因。写入 WAL 条目后可能会崩溃，但这没关系，只要我们知道属于每个 WAL 条目的事务状态，我们就可以在恢复时丢弃或忽略未提交的 WAL 条目。
例如，如果我们正处于事务过程中并且数据库崩溃了，我们默认会认为该事务已回滚，因此由该未提交事务刷新的 WAL 条目将被丢弃。
但是，如果我们能够发出 COMMIT 并且事务提交的 WAL 条目将其写入磁盘并且客户端获得一个成功的反馈，则即使我们立即崩溃，该事务也会被视为已提交。
因此，我们已经确定 WAL 是事实来源，当我们在数据文件之前写入时，我们当然会将更改写入内存中的数据页（以便正在进行的事务使用最新的数据页），但我们会延迟刷新数据页数据页写入磁盘，因为 WAL 已将其写入磁盘。
现在，我们的磁盘上的数据文件与内存中的数据文件不同步，这绝对没问题。只要数据库正在运行，我们就只会从内存中读取最新的数据，但如果我们确实崩溃了，那就是一个问题。
当数据库开始备份时，文件已过时，我们不能只是将其拉到内存中并让客户端读取它们，WAL 是事实来源，我们需要将 WAL 中的更改重做回数据文件上，并且在此过程中不允许读取任何内容（否则我们会损坏）。数据文件与 WAL 的不同步程度越高（发生了多次写入，但数据文件很长时间没有更新），数据库启动时间就越慢。</description>
    </item>
    
    <item>
      <title>项目中关于Go字符串拼接的一些思考</title>
      <link>https://baniycai.github.io/article/go_string_splice/</link>
      <pubDate>Mon, 20 Nov 2023 17:17:19 +0800</pubDate>
      
      <guid>https://baniycai.github.io/article/go_string_splice/</guid>
      <description>实际场景 ​	今天在review我们两个核心项目代码的时候，发现项目中大量调用了fmt.Sprintf方法，即使是简单的两个字符串的拼接(没有任何分隔符)也使用了这个方法，对于一个接近疯狂的代码性能追求党，怎么能容忍这种代码的存在呢！！！
ps：两个项目，一个是实时项目，业务相对比较简单，接收外部请求，进行各种过滤后返回广告素材相关信息，请求响应时间不能超过1s，该项目暂称为F(fast)；一个是收数的项目，业务相对比较复杂，同样是接收外部请求，但是返回一个响应码就行，而且对响应时间没有太大的要求，基本是有响应就行，该项目暂称为S(slow)
​	转头一想，性能优化也是要做权衡考虑的，不是说性能最高的代码就是最好的代码，还要结合实际场景来考虑！我们知道，fmt.Sprintf()方法主要是用来做字符串的拼接，比如说redisKey := fmt.Sprintf(&amp;quot;%d_%d_%d&amp;quot;, planId, itemId, unit)，这样的代码比起简单地使用+操作符来实现，可读性高了很多。但是，往往没有十全十美的方案，可读性的提升带来的是性能的降低。废话不多说，上基准测试！！！
package main import ( &amp;#34;testing&amp;#34; &amp;#34;fmt&amp;#34; ) // 使用 + 操作符拼接字符串 func concatWithPlusOperator(a, b string) string { return a + b } // 使用 fmt.Printf 拼接字符串 func concatWithPrintf(a, b string) string { return fmt.Sprintf(&amp;#34;%s%s&amp;#34;, a, b) } // 基准测试函数 func BenchmarkStringConcatenation(b *testing.B) { a := &amp;#34;Hello&amp;#34; benchmarkCases := []struct { name string concat func(string, string) string }{ {&amp;#34;PlusOperator&amp;#34;, concatWithPlusOperator}, {&amp;#34;Printf&amp;#34;, concatWithPrintf}, } for _, bm := range benchmarkCases { b.</description>
    </item>
    
    <item>
      <title>AWS S3 &#43; CloudFront</title>
      <link>https://baniycai.github.io/article/aws_cloudfront/</link>
      <pubDate>Fri, 03 Nov 2023 23:19:44 +0800</pubDate>
      
      <guid>https://baniycai.github.io/article/aws_cloudfront/</guid>
      <description>&lt;h3 id=&#34;快速大规模地存储和分发内容&#34;&gt;快速、大规模地存储和分发内容&lt;/h3&gt;
&lt;p&gt;​	如果你有一个网站、应用程序或其他web资源，那么你可能会有静态资源。静态资源包括图像、视频或音乐等文件，还包括像 .css 或 js 等脚本文件。在云服务还未流行的时代，你可以将这些文件放在服务器上，然后通过互联网将它们提供给全球某个特定地理位置的所有受众。但有了云服务，就有一种解决方案可以提供更快的交付和更好的可扩展性。在这篇博客中，你将了解如何使用 Amazon Simple Storage Service (S3) 和 Amazon CloudFront 大规模存储、保护和交付你的静态资源。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gin_source_code_summary</title>
      <link>https://baniycai.github.io/article/gin_source_code_summary/</link>
      <pubDate>Sat, 03 Jun 2023 21:59:54 +0800</pubDate>
      
      <guid>https://baniycai.github.io/article/gin_source_code_summary/</guid>
      <description>前言 ​	小弟一直以来都对各种技术或框架的底层原理很感兴趣，自认为只有把这项技术的底层原理都摸透了，才能很好地驾驭这门技术，减少踩坑和犯错的可能。
​	最近刚好想学习golang的各个web框架，了解下它们的底层以及它们之间有什么区别，所以就开始了源码之旅~~~
​	这周的下班时间加上周末的一点点时间，大概地看了下golang源码的http包和gin web框架的大部分代码。golang源码的http包内容相对简单，且路由功能相对单一，只支持绝对匹配路由(会一点小调整啦，后面再细讲)，但对于大部分简单的场景是完全足够的啦，这里就不讲了，后面找时间再来详细说下，今天重点讲下gin框架的源码~~~
源码解读 ​	关于gin的介绍就不说啦，网上一大堆介绍，且这篇文章的重点是讲源码，所以就直接开始源码之旅叭 (小声bb：这只是小弟的个人总结和理解，不一定对，理性看哈，而且随着知识学习的深入，后面可能还会对内容进行改进哈)
​	感觉gin最关键的两个结构应该是Engine和Context了。Engine实现了http.Handler接口，在ServeHTTP(ResponseWriter, *Request)中接收到请求后，从Engine的methodTrees方法树中找出能处理该请求path的handlers，之后将req和res包装成Context传给该handlers进行处理，下面是gin中的hander的方法签名
type HandlerFunc func(*Context) todo 未完待续</description>
    </item>
    
    <item>
      <title>MakeFile介绍</title>
      <link>https://baniycai.github.io/article/makefile_intro/</link>
      <pubDate>Sun, 14 May 2023 21:15:40 +0800</pubDate>
      
      <guid>https://baniycai.github.io/article/makefile_intro/</guid>
      <description>&lt;h3 id=&#34;makefile-规则&#34;&gt;Makefile 规则&lt;/h3&gt;
&lt;p&gt;在程序编译过程中，&lt;a href=&#34;https://www.zhaixue.cc/makefile/makefile-intro.html&#34;&gt;Makefile&lt;/a&gt;的主要作用就是：构建生成可执行文件的依赖关系树。&lt;strong&gt;一个可执行文件需要哪些源文件、哪些库，我们都可以在&lt;a href=&#34;https://www.zhaixue.cc/makefile/makefile-intro.html&#34;&gt;Makefile&lt;/a&gt;里指定&lt;/strong&gt;。在程序编译阶段，make工具会首先解析这个&lt;a href=&#34;https://www.zhaixue.cc/makefile/makefile-intro.html&#34;&gt;Makefile&lt;/a&gt;，根据&lt;a href=&#34;https://www.zhaixue.cc/makefile/makefile-intro.html&#34;&gt;Makefile&lt;/a&gt;里的指定，构建出编译可执行文件所需要的完整依赖关系。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Support and Discussions</title>
      <link>https://baniycai.github.io/article/support-and-discussions/</link>
      <pubDate>Mon, 01 Nov 2021 18:10:14 +0100</pubDate>
      
      <guid>https://baniycai.github.io/article/support-and-discussions/</guid>
      <description>Support for this theme is provided through the Issues and Discussions sections of the project. Please use the Issues section if you would like to report a defect or bug. For any other requests, use the Discussions section.
Please use the following guidelines if you want to start a discussion:
For any questions regarding a specific feature, or if you need help using or customizing the theme, use the Questions &amp;amp; Answers (Q&amp;amp;A) category.</description>
    </item>
    
  </channel>
</rss>
